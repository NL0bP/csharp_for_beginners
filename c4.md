# ГЛАВА 4. Операторы
В языке C# предусмотрен обширный ряд операторов,
предоставляющих программирующему возможность
полного контроля над построением и вычислением
выражений. Большинство операторов в С# относится к следующим категориям: арифметические, поразрядные, логические и операторы отношения. Все перечисленные категории
операторов рассматриваются в этой главе. Кроме того, в C#
предусмотрен ряд других операторов для особых случаев,
включая индексирование массивов, доступ к членам класса
и обработку лямбда-выражений. Эти специальные операторы рассматриваются далее в книге вместе с теми средствами, в которых они применяются.

## Арифметические операторы
Арифметические операторы, представленные в языке
С#, приведены ниже.

| Оператор | Действие                 |
|----------|--------------------------|
| +        | Сложение                 |
| -        | Вычитание, унарный минус |
| *        | Умножение                |
| /        | Деление                  |
| %        | Деление по модулю        |
| —        | Декремент                |
| ++       | Инкремент                |

Операторы +, -, * и / действуют так, как предполагает их обозначение. Их можно
применять к любому встроенному числовому типу данных.

Действие арифметических операторов не требует особых пояснений, за исключением следующих особых случаев. Прежде всего, не следует забывать, что когда оператор
/ применяется к целому числу, то любой остаток от деления отбрасывается; например,
результат целочисленного деления 10/3 будет равен 3. Остаток от этого деления можно
получить с помощью оператора деления по модулю (%), который иначе называется
оператором вычисления остатка. Он дает остаток от целочисленного деления. Например, 10 % 3 равно 1. В C# оператор % можно применять как к целочисленным типам
данных, так и к типам с плавающей точкой. Поэтому 10.0 % 3.0 также равно 1.
В этом отношении C# отличается от языков С и C++, где операции деления по модулю
разрешаются только для целочисленных типов данных. В приведенном ниже примере
программы демонстрируется применение оператора деления по модулю.
```
// Продемонстрировать применение оператора %.
using System;

class ModDemo {
    static void Main() {
        int iresult, irem;
        double dresult, drem;
        iresult = 10 / 3;
        irem = 10 % 3;
        dresult = 10.0 / 3.0;
        drem = 10.0 % 3.0;
        Console.WriteLine("Результат и остаток от деления 10/3: " +
                        iresult + " " + irem);
        Console.WriteLine("Результат и остаток от деления 10.0 / 3.0: " +
                        dresult + " " + drem);
    }
}
```
Результат выполнения этой программы приведен ниже.
```
Результат и остаток от деления 10 / 3: 3 1
Результат и остаток от деления 10.0 / 3.0: 3.33333333333333 1
```
Как видите, обе операции, % целочисленного типа и с плавающей точкой, дают
один и тот же остаток, равный 1.

### Операторы инкремента и декремента
Операторы инкремента (++) и декремента (--) были представлены в главе 2. Как
станет ясно в дальнейшем, они обладают рядом особых и довольно интересных свойств.
Но сначала выясним основное назначение этих операторов.

Оператор инкремента увеличивает свой операнд на 1, а оператор декремента
уменьшает операнд на 1. Следовательно, оператор
```
х++;
```
равнозначен оператору
```
х = x + 1;
```
а оператор
```
х--;
```
равносилен оператору
```
х = х - 1;
```
Следует, однако, иметь в виду, что в инкрементной или декрементной форме значение переменной х вычисляется только один, а не два раза. В некоторых случаях это
позволяет повысить эффективность выполнения программы.

Оба оператора инкремента и декремента можно указывать до операнда (в префиксной форме) или же после операнда (в постфиксной форме). Например, оператор
```
х = х + 1;
```
может быть записан в следующем виде:
```
++х; // префиксная форма
```
или же в таком виде:
```
х++; // постфиксная форма
```
В приведенном выше примере форма инкремента (префиксная или постфиксная)
особого значения не имеет. Но если оператор инкремента или декремента используется в длинном выражении, то отличие в форме его записи уже имеет значение. Когда
оператор инкремента или декремента предшествует своему операнду, то результатом
операции становится значение операнда после инкремента или декремента. А когда
оператор инкремента или декремента следует после своего операнда, то результатом
операции становится значение операнда до инкремента или декремента. Рассмотрим
следующий фрагмент кода.
```
х = 10;
у = ++х;
```
В данном случае значение переменной у будет установлено равным 11, поскольку
значение переменной х сначала увеличивается на 1, а затем присваивается переменной
у. Но во фрагменте кода
```
х = 10;
у = х++;
```
значение переменной у будет установлено равным 10, так как в этом случае значение
переменной х сначала присваивается переменной у, а затем увеличивается на 1. В обоих случаях значение переменной х оказывается равным 11. Отличие состоит лишь том,
когда именно это значение станет равным 11: до или после его присваивания переменной у.

Возможность управлять моментом инкремента или декремента дает немало преимуществ при программировании. Обратимся к следующему примеру программы,
в которой формируется последовательный ряд чисел.
```
// Продемонстрировать отличие между префиксной
// и постфиксной формами оператора инкремента (++).
using System;

class PrePostDemo {
    static void Main() {
        int x, y;
        int i;
        x = 1;
        У = 0;
        Console.WriteLine("Ряд чисел, полученных " +
                        "с помощью оператора у = у + х++;");
        for(i = 0; i < 10; i++) {
            у = у + х++; // постфиксная форма оператора ++
            Console.WriteLine(у + " ");
        }
        Console.WriteLine();
        x = 1;
        У = 0;
        Console.WriteLine("Ряд чисел, полученных " +
                        "с помощью оператора у = у + ++х;");
        for(i = 0; i < 10; i++) {
            у = у + ++х; // префиксная форма оператора ++
            Console.WriteLine(у + " ");
        }
        Console.WriteLine();
    }
}
```
Выполнение этой программы дает следующий результат.
```
Ряд чисел, полученных с помощью оператора у = у + х++
1
3
6
10
15
14
21
28
36
45
55
Ряд чисел, полученных с помощью оператора у = у + ++х;
2
5
9
14
20
27
35
44
54
65
```
Как подтверждает приведенный выше результат, в операторе
```
у = у + х++;
```
первоначальное значение переменной х складывается с самим собой, а полученный
результат присваивается переменной у. После этого значение переменной х увеличивается на 1. Но в операторе
```
у = у + ++х;
```
значение переменной х сначала увеличивается на 1, затем складывается с первоначальным значением этой же переменной, а полученный результат присваивается переменной у. Как следует из приведенного выше результата, простая замена префиксной
формы записи оператора ++х постфиксной формой х++ приводит к существенному
изменению последовательного ряда получаемых чисел.

И еще одно замечание по поводу приведенного выше примера: не пугайтесь выражений, подобных следующему:
```
у + ++x
```
Такое расположение рядом двух операторов может показаться не совсем привычным, но компилятор воспримет их в правильной последовательности. Нужно лишь
запомнить, что в данном выражении значение переменной у складывается с увеличенным на 1 значением переменной х.

## Операторы отношения и логические операторы
В обозначениях оператор отношения и логический оператор термин отношения означает взаимосвязь, которая может существовать между двумя значениями, а термин
логический — взаимосвязь между логическими значениями "истина" и "ложь". И поскольку операторы отношения дают истинные иди ложные результаты, то они нередко применяются вместе с логическими операторами. Именно по этой причине они и
рассматриваются совместно в данном разделе.

Ниже перечислены операторы отношения.

| Оператор | Значение         |
|----------|------------------|
| ==       | Равно            |
| !=       | Не равно         |
| >        | Больше           |
| <        | Меньше           |
| >        | Больше или равно |
| <=       | Меньше или равно |

К числу логических относятся операторы, приведенные ниже.

Результатом выполнения оператора отношения или логического оператора является логическое значение типа bool.

В целом, объекты можно сравнивать на равенство или неравенство, используя операторы отношения == и !=. А операторы сравнения <, >, <= или >= могут применяться
только к тем типам данных, которые поддерживают отношение порядка. Следовательно, операторы отношения можно применять ко всем числовым типам данных. Но значения типа bool могут сравниваться только на равенство или неравенство, поскольку
истинные (true) и ложные (false) значения не упорядочиваются. Например, сравнение true > false в C# не имеет смысла.

Операнды логических операторов должны относиться к типу bool, а результат выполнения логической операции также относится к типу bool. Логические операторы
&, |, ^ и ! поддерживают основные логические операции И, ИЛИ, исключающее ИЛИ
и НЕ в соответствии с приведенной ниже таблицей истинности.

| p     | q     | p & q | p &vert; q | p ^ q | &vert;P    |
|-------|-------|-------|-------|-------|-------|
| false | false | false | false | false | true  |
| true  | false | false | true  | true  | false |
| false | true  | false | true  | true  | true  |
| true  | true  | true  | true  | false | false |

Как следует из приведенной выше таблицы, результатом выполнения логической
операции исключающее ИЛИ будет истинное значение (true), если один и только
один ее операнд имеет значение true.

Ниже приведен пример программы, демонстрирующий применение нескольких
операторов отношения и логических операторов.
```
// Продемонстрировать применение операторов
// отношения и логических операторов.
using System;

class RelLogOps {
    static void Main() {
        int i, j;
        bool b1, b2;
        i = 10;
        j = 11;
        if(i < j) Console.WriteLine("i < j");
        if(i <= j) Console.WriteLine("i <= j");
        if(i != j) Console.WriteLine("i != j");
        if(i == j) Console.WriteLine("Нельзя выполнить");
        if(i >= j) Console.WriteLine("Нельзя выполнить");
        if(i > j) Console.WriteLine("Нельзя выполнить");
        b1 = truer
        b2 = false;
        if(b1 & b2) Console.WriteLine("Нельзя выполнить");
        if(!(b1 & b2)) Console.WriteLine("!(b1 & b2) — true");
        if(b1 | b2) Console.WriteLine("b1 | b2 - true");
        if(b1 ^ b2) Console.WriteLine("bl ^ b2 — true");
    }
}
```
Выполнение этой программы дает следующий результат.
```
i < j
i <= j
i != j
!(b1 & b2) — true
b1 | b2 — true
b1 ^ b2 — true
```
Логические операторы в C# выполняют наиболее распространенные логические
операции. Тем не менее существует ряд операций, выполняемых по правилам формальной логики. Эти логические операции могут быть построены с помощью логических операторов, поддерживаемых в С#. Следовательно, в C# предусмотрен такой набор логических операторов, которого достаточно для построения практически любой
логической операции, в том числе импликации. Импликация — это двоичная операция, результатом которой является ложное значение только в том случае, если левый
ее операнд имеет истинное значение, а правый — ложное. (Операция импликации отражает следующий принцип: истина не может подразумевать ложь.) Ниже приведена
таблица истинности для операции импликации.

| p     | q     | Результат импликации p и q |
|-------|-------|----------------------------|
| true  | true  | true                       |
| true  | false | false                      |
| false | false | true                       |
| false | true  | true                       |

Операция импликации может быть построена на основе комбинации логических
операторов ! и |, как в приведенной ниже строке кода.
```
!р | q
```
В следующем примере программы демонстрируется подобная реализация операции импликации.
```
// Построение операции импликации в С#.
using System;

class Implication {
    static void Main() {
        bool p=false, q=false;
        int i, j;
        for(i = 0; i < 2; i++) {
            for(j = 0; j < 2; j++) {
                if(i==0) p = true;
                if(i==1) p = false;
                if(j==0) q = true;
                if(j==1) q = false;
                Console.WriteLine("p равно " + p + ", q равно " + q);
                if(!p | q)
                    Console.WriteLine("Результат импликации " + p +
                                    " и " + q + " равен " + true);
                Console.WriteLine();
            }
        }
    }
}
```
Результат выполнения этой программы выглядит так.
```
р равно True, q равно True
Результат импликации True и True равен True
р равно True, q равно False
р равно False, q равно False
Результат импликации False и True равен True
р равно False, q равно False
Результат импликации False и False равен True
```

### Укороченные логические операторы
В C# предусмотрены также специальные, укороченные, варианты логических операторов И и ИЛИ, предназначенные для получения более эффективного кода. Поясним
это на следующих примерах логических операций. Если первый операнд логической
операции И имеет ложное значение (false), то ее результат будет иметь ложное значение независимо от значения второго операнда. Если же первый операнд логической
операции ИЛИ имеет истинное значение (true), то ее результат будет иметь истинное
значение независимо от значения второго операнда. Благодаря тому что значение второго операнда в этих операциях вычислять не нужно, экономится время и повышается
эффективность кода.

Укороченная логическая операция И выполняется с помощью оператора &&, а укороченная логическая операция ИЛИ — с помощью оператора ||. Этим укороченным
логическим операторам соответствуют обычные логические операторы & и |. Единственное отличие укороченного логического оператора от обычного заключается в том,
что второй его операнд вычисляется только по мере необходимости.

В приведенном ниже примере программы демонстрируется применение укороченного логического оператора И. В этой программе с помощью операции деления по
модулю определяется следующее: делится ли значение переменной d на значение переменной n нацело. Если остаток от деления n/d равен нулю, то n делится на d нацело.
Но поскольку данная операция подразумевает деление, то для проверки условия деления на нуль служит укороченный логический оператор И.
```
// Продемонстрировать применение укороченных логических операторов.
using System;

class SCops {
    static void Main() {
        int n, d;
        n = 10;
        d = 2;
        if (d ! = 0 && (n % d) == 0)
            Console.WriteLine(n + " делится нацело на " + d);
        d = 0; // задать нулевое значение переменной d
        // d равно нулю, поэтому второй операнд не вычисляется
        if (d != 0 && (n % d) == 0)
            Console.WriteLine(n + " делится нацело на " + d);
        // Если теперь попытаться сделать то же самое без укороченного
        // логического оператора, то возникнет ошибка из-за деления на нуль.
        if (d != 0 & (n % d) == 0)
            Console.WriteLine(n + " делится нацело на " + d);
    }
}
```
Для исключения ошибки из-за деления на нуль в операторе if сначала проверяется условие: равно ли нулю значение переменной d. Если оно равно нулю, то на этом
выполнение укороченного логического оператора И завершается, а последующая операция деления по модулю не выполняется. Так, при первой проверке значение переменной d оказывается равным 2, поэтому выполняется операция деления по модулю.
А при второй проверке это значение оказывается равным нулю, следовательно, операция деления по модулю пропускается, чтобы исключить деление на нуль. И наконец,
выполняется обычный логический оператор И, когда вычисляются оба операнда. Если
при этом происходит деление на нуль, то возникает ошибка при выполнении.

Укороченные логические операторы иногда оказываются более эффективными,
чем их обычные аналоги. Так зачем же нужны обычные логические операторы И и
ИЛИ? Дело в том, что в некоторых случаях требуется вычислять оба операнда логической операции И либо ИЛИ из-за возникающих побочных эффектов. Рассмотрим
следующий пример программы.
```
// Продемонстрировать значение побочных эффектов.
using System;

class SideEffects {
    static void Main() {
        int i;
        bool someCondition = false;
        i = 0;
        // Значение переменной i инкрементируется,
        // несмотря на то, что оператор if не выполняется.
        if(someCondition & (++i < 100))
            Console.WriteLine("He выводится");
        Console.WriteLine("Оператор if выполняется: " + i); // выводится 1
        // В данном случае значение переменной i не инкрементируется,
        // поскольку инкремент в укороченном логическом операторе опускается.
        if(someCondition && (++i < 100))
            Console.WriteLine("He выводится");
        Console.WriteLine("Оператор if выполняется: " + i); // по-прежнему 1 !!
    }
}
```
Прежде всего обратим внимание на то, что переменная someCondition типа bool
инициализируется значением false. Далее проанализируем каждый оператор if.
Как следует из комментариев к данной программе, в первом операторе if переменная i инкрементируется, несмотря на то что значение переменной someCondition
равно false. Когда применяется логический оператор &, как это имеет место в первом
операторе if, выражение в правой части этого оператора вычисляется независимо от
значения выражения в его левой части. А во втором операторе if применяется укороченный логический оператор. В этом случае значение переменной i не инкрементируется, поскольку левый операнд (переменная someCondition) имеет значение false,
следовательно, выражение в правой части данного оператора пропускается. Из этого
следует вывод: если в коде предполагается вычисление правого операнда логической
операции И либо ИЛИ, то необходимо пользоваться неукороченными формами логических операций, доступных в С#.

И последнее замечание: укороченный оператор И называется также условным логическим оператором И, а укороченный оператор ИЛИ — условным логическим оператором
ИЛИ.

## Оператор присваивания
Оператор присваивания обозначается одиночным знаком равенства (=). В С# оператор присваивания действует таким же образом, как и в других языках программирования. Ниже приведена его общая форма.
```
имя_переменной = выражение
```
Здесь имя_переменной должно быть совместимо с типом выражения.

У оператора присваивания имеется одна интересная особенность, о которой вам
будет полезно знать: он позволяет создавать цепочку операций присваивания. Рассмотрим, например, следующий фрагмент кода.
```
int х, у, z;
х = у = z = 100; // присвоить значение 100 переменным х, у и z
```
В приведенном выше фрагменте кода одно и то же значение 100 задается для переменных х, у и z с помощью единственного оператора присваивания. Это значение
присваивается сначала переменной z, затем переменной у и, наконец, переменной х.
Такой способ присваивания "по цепочке" удобен для задания общего значения целой
группе переменных.

### Составные операторы присваивания
В C# предусмотрены специальные составные операторы присваивания, упрощающие программирование некоторых операций присваивания. Обратимся сначала к
простому примеру. Приведенный ниже оператор присваивания
```
х = х + 10;
```
можно переписать, используя следующий составной оператор присваивания.
```
х += 10;
```
Пара операторов += указывает компилятору на то, что переменной х должно быть
присвоено ее первоначальное значение, увеличенное на 10.

Рассмотрим еще один пример. Оператор
```
х = х - 100;
```
и оператор
```
x -= 100;
```
выполняют одни и те же действия. Оба оператора присваивают переменной х ее первоначальное значение, уменьшенное на 100.

Для многих двоичных операций, т.е. операций, требующих наличия двух операндов, существуют отдельные составные операторы присваивания. Общая форма всех
этих операторов имеет следующий вид;
```
имя_переменной ор = выражение
```
где ор — арифметический или логический оператор, применяемый вместе с оператором присваивания.

Ниже перечислены составные операторы присваивания для арифметических и логических операций.

|    |    |    |    |
|----|----|----|----|
| += | -= | *= | /= |
| %= | &= | &vert;= | ^= |

Составные операторы присваивания записываются более кратко, чем их несоставные эквиваленты. Поэтому их иногда еще называют укороченными операторами
присваивания.

У составных операторов присваивания имеются два главных преимущества. Во-
первых, они более компактны, чем их "несокращенные" эквиваленты. И во-вторых, они
дают более эффективный исполняемый код, поскольку левый операнд этих операторов
вычисляется только один раз. Именно по этим причинам составные операторы присваивания чаще всего применяются в программах, профессионально написанных на С#.

## Поразрядные операторы
В C# предусмотрен ряд поразрядных операторов, расширяющих круг задач, для решения которых можно применять С#. Поразрядные операторы воздействуют на отдельные двоичные разряды (биты) своих операндов. Они определены только для целочисленных операндов, поэтому их нельзя применять к данным типа bool, float или
double.

Эти операторы называются поразрядными, поскольку они служат для проверки,
установки или сдвига двоичных разрядов, составляющих целое значение. Среди прочего поразрядные операторы применяются для решения самых разных задач программирования на уровне системы, включая, например, анализ информации состояния
устройства. Все доступные в C# поразрядные операторы приведены в табл. 4.1.

Таблица 4.1. Поразрядные операторы

| Оператор | Значение                              |
|----------|---------------------------------------|
| &        | Поразрядное И                         |
| &vert;        | Поразрядное ИЛИ                       |
| ^        | Поразрядное исключающее ИЛИ           |
| >        | Сдвиг вправо                          |
| <<       | Сдвиг влево                           |
| ~        | Дополнение до 1 (унарный оператор НЕ) |

### Поразрядные операторы И, ИЛИ, исключающее ИЛИ и НЕ
Поразрядные операторы И, ИЛИ, исключающее ИЛИ и НЕ обозначаются следующим образом: &, |, ^ и ~. Они выполняют те же функции, что и их логические аналоги,
рассмотренные выше. Но в отличие от логических операторов, поразрядные операторы действуют на уровне отдельных двоичных разрядов. Ниже приведены результаты
поразрядных операций с двоичными единицами и нулями.

| Р | q | р & q | р &vert; q | р ^ q | ~р |
|---|---|-------|------------|-------|----|
| 0 | 0 | 0     | 0          | 0     | 1  |
| 1 | 0 | 0     | 1          | 1     | 0  |
| 0 | 1 | 0     | 1          | 1     | 1  |
| 1 | 1 | 1     | 1          | 0     | 0  |

С точки зрения наиболее распространенного применения поразрядную операцию
И можно рассматривать как способ подавления отдельных двоичных разрядов. Это
означает, что если какой-нибудь бит в любом из операндов равен 0, то соответствующий бит результата будет сброшен в 0. Например:
```
1101 0011
1010 1010
& __________
1000 0010
```
В приведенном ниже примере программы демонстрируется применение поразрядного оператора & для преобразования нечетных чисел в четные. Для этой цели
достаточно сбросить младший разряд числа. Например, число 9 имеет следующий
двоичный вид: 0000 1001. Если сбросить младший разряд этого числа, то оно станет
числом 8, а в двоичной форме — 0000 1000.
```
// Применить поразрядный оператор И, чтобы сделать число четным.
using System;

class MakeEven {
    static void Main() {
        ushort num;
        ushort i;
        for(i = 1; i <= 10; i++) {
            num = i;
            Console.WriteLine("num: " + num);
            num = (ushort) (num & 0xFFFE);
            Console.WriteLine("num после сброса младшего разряда: "
                            + num + "\n");
        }
    }
}
```
Результат выполнения этой программы приведен ниже.
```
num: 1
num после сброса младшего разряда: 0
num: 2
num после сброса младшего разряда: 2
num: 3
num после сброса младшего разряда: 2
num: 4
num после сброса младшего разряда: 4
num: 5
num после сброса младшего разряда: 4
num: 6
num после сброса младшего разряда: 6
num: 7
num после сброса младшего разряда: 6
num: 8
num после сброса младшего разряда: 8
num: 9
num после сброса младшего разряда: 8
num: 10
num после сброса младшего разряда: 10
```
Шестнадцатеричное значение 0xFFFE, используемое в поразрядном операторе
И, имеет следующую двоичную форму: 1111 1111 1111 1110. Таким образом, поразрядная операция И оставляет без изменения все двоичные разряды в числовом значении переменной num, кроме младшего разряда, который сбрасывается в нуль. В итоге
четные числа не претерпевают никаких изменений, а нечетные уменьшаются на 1 и
становятся четными.

Поразрядным оператором И удобно также пользоваться для определения установленного или сброшенного состояния отдельного двоичного разряда. В следующем
примере программы определяется, является ли число нечетным.
```
// Применить поразрядный оператор И, чтобы определить,
// является ли число нечетным.
using System;

class IsOdd {
    static void Main() {
        ushort num;
        num = 10;
        if((num & 1) == 1)
            Console.WriteLine("He выводится.");
        num = 11;
        if((num & 1) == 1)
            Console.WriteLine(num + " — нечетное число.");
    }
}
```
Вот как выглядит результат выполнения этой программы.
```
11 — нечетное число.
```
В обоих операторах if из приведенной выше программы выполняется поразрядная
операция И над числовыми значениями переменной num и 1. Если младший двоичный разряд числового значения переменной num установлен, т.е. содержит двоичную
1, то результат поразрядной операции num & 1 оказывается равным 1. В противном
случае он равен нулю. Поэтому оператор if может быть выполнен успешно лишь в
том случае, если проверяемое число оказывается нечетным.

Возможностью проверять состояние отдельных двоичных разрядов с помощью поразрядного оператора & можно воспользоваться для написания программы, в которой
отдельные двоичные разряды проверяемого значения типа byte приводятся в двоичной форме. Ниже показан один из способов написания такой программы.
```
// Показать биты, составляющие байт.
using System;

class ShowBits {
    static void Main() {
        int t;
        byte val;
        val = 123;
        for (t=l28; t > 0; t = t/2) {
        if((val & t) != 0) Console.Write("1 ");
        if((val & t) == 0) Console.Write("0 ");
        }
    }
}
```
Выполнение этой программы дает следующий результат.
```
0 1 1 1 1 0 1 1
```
В цикле for из приведенной выше программы каждый бит значения переменной
val проверяется с помощью поразрядного оператора И, чтобы выяснить, установлен
ли этот бит или сброшен. Если он установлен, то выводится цифра 1, а если сброшен,
то выводится цифра 0.

Поразрядный оператор ИЛИ может быть использован для установки отдельных двоичных разрядов. Если в 1 установлен какой-нибудь бит в любом из операндов этого оператора, то в 1 будет установлен и соответствующий бит в другом операнде. Например:
```
1101 0011
1010 1010
| __________
1111 1011
```
Используя поразрядный оператор ИЛИ, можно без особого труда превратить упоминавшийся выше пример программы, преобразующей нечетные числа в четные,
в приведенный ниже обратный пример, где четные числа преобразуются в нечетные.
```
// Применить поразрядный оператор ИЛИ, чтобы сделать число нечетным.
using System;

class MakeOdd {
    static void Main() {
        ushort num;
        ushort i;
        for(i = 1; i <= 10; i++) {
            num = i;
            Console.WriteLine("num: " + num);
            num = (ushort) (num | 1);
            Console.WriteLine("num после установки младшего разряда: " +
                            num + "\n");
        }
    }
}
```
Результат выполнения этой программы выглядит следующим образом.
```
num: 1
num после установки младшего разряда: 1
num: 2
num после установки младшего разряда: 3
num: 3
num после установки младшего разряда: 3
num: 4
num после установки младшего разряда: 5
num: 5
num после установки младшего разряда: 5
num: 6
num после установки младшего разряда: 7
num: 7
num после установки младшего разряда: 7
num: 8
num после установки младшего разряда: 9
num: 9
num после установки младшего разряда: 9
num: 10
num после установки младшего разряда: 11
```
В приведенной выше программе выполняется поразрядная операция ИЛИ над
каждым числовым значением переменной num и 1, поскольку 1 дает двоичное значение, в котором установлен младший разряд. В результате поразрядной операции ИЛИ
над 1 и любым другим значением младший разряд последнего устанавливается, тогда
как все остальные разряды остаются без изменения. Таким образом, результирующее
числовое значение получается нечетным, если исходное значение было четным.

Поразрядный оператор исключающее ИЛИ устанавливает двоичный разряд операнда в том и только в том случае, если двоичные разряды сравниваемых операндов
оказываются разными, как в приведенном ниже примере.
```
0111 1111
1011 1001
^ __________
1100 0110
```
У поразрядного оператора исключающее ИЛИ имеется одно интересное свойство,
которое оказывается полезным в самых разных ситуациях. Так, если выполнить сначала поразрядную операцию исключающее ИЛИ одного значения X с другим значением
Y, а затем такую же операцию над результатом предыдущей операции и значением Y,
то вновь получится первоначальное значение X. Это означает, что в приведенном ниже
фрагменте кода
```
R1 = X ^ Y;
R2 = R1 ^ Y;
```
значение переменной R2 оказывается в итоге таким же, как и значение переменной X.
Следовательно, в результате двух последовательно выполняемых поразрядных операций исключающее ИЛИ, в которых используется одно и то же значение, подучается
первоначальное значение. Этим свойством данной операции можно воспользоваться
для написания простой программы шифрования, в которой некоторое целое значение
служит в качестве ключа для кодирования и декодирования сообщения с помощью
операции исключающее ИЛИ над символами этого сообщения. В первый раз операция исключающее ИЛИ выполняется для кодирования открытого текста в зашифрованный, а второй раз — для декодирования зашифрованного текста в открытый. Разумеется, такое шифрование не представляет никакой практической ценности, поскольку оно может быть легко разгадано. Тем не менее оно служит интересным примером
для демонстрации результатов применения поразрядных операторов исключающее
ИЛИ, как в приведенной ниже программе.
```
// Продемонстрировать применение поразрядного оператора исключающее ИЛИ.
using System;

class Encode {
    static void Main() {
        char ch1 = 'H';
        char ch2 = 'i';
        char ch3 = '!';
        int key = 88;
        Console.WriteLine("Исходное сообщение: " + ch1 + ch2 + ch3);
        // Зашифровать сообщение.
        ch1 = (char) (ch1 ^ key);
        ch2 = (char) (ch2 ^ key);
        ch3 = (char) (ch3 ^ key);
        Console.WriteLine("Зашифрованное сообщение: " + ch1 + ch2 + ch3);
        // Расшифровать сообщение.
        ch1 = (char) (ch1 ^ key);
        ch2 = (char) (ch2 ^ key);
        ch3 = (char) (ch3 ^ key);
        Console.WriteLine("Расшифрованное сообщение: " + ch1 + ch2 + ch3);
    }
}
```
Ниже приведен результат выполнения этой программы.
```
Исходное сообщение: Hi!
Зашифрованное сообщение: □1y
Расшифрованное сообщение: Hi!
```
Как видите, в результате выполнения двух последовательностей поразрядных операций исключающее ИЛИ получается расшифрованное сообщение. (Еще раз напомним, что такое шифрование не имеет никакой практической ценности, поскольку оно,
в сущности, ненадежно.)

Поразрядный унарный оператор НЕ (или оператор дополнения до 1) изменяет на
обратное состояние всех двоичных разрядов операнда. Так, если некоторое целое значение А имеет комбинацию двоичных разрядов 1001 0110, то в результате поразрядной
операции ~А получается значение с комбинацией двоичных разрядов 0110 1001.

В следующем примере программы демонстрируется применение поразрядного
оператора НЕ с выводом некоторого числа и его дополнения до 1 в двоичном коде.
```
// Продемонстрировать применение поразрядного унарного оператора НЕ.
using System;

class NotDemo {
    static void Main() {
        sbyte b = -34;
        for(int t=128; t > 0; t = t/2) {
            if((b & t) != 0) Console.Write("1 ");
            if((b & t) == 0) Console.Write("0 ");
        }
        Console.WriteLine();
        // обратить все биты
        b = (sbyte) ~b;
        for(int t=128; t > 0; t = t/2) {
            if((b & t) != 0) Console.Write("1 ");
            if((b & t) == 0) Console.Write("0 ");
        }
    }
}
```
Результат выполнения этой программы приведен ниже.
```
1 1 0 1 1 1 1 0
0 0 1 0 0 0 0 1
```

### Операторы сдвига
В C# имеется возможность сдвигать двоичные разряды, составляющие целое значение, влево или вправо на заданную величину. Для этой цели в C# определены два
приведенных ниже оператора сдвига двоичных разрядов.

|    |              |
|----|--------------|
| << | Сдвиг влево  |
| >> | Сдвиг вправо |

Ниже приведена общая форма для этих операторов:
```
значение << число_битов
значение >> число_битов
```
где число_битов — это число двоичных разрядов, на которое сдвигается указанное
значение.

При сдвиге влево все двоичные разряды в указываемом значении сдвигаются на
одну позицию влево, а младший разряд сбрасывается в нуль. При сдвиге вправо все
двоичные разряды в указываемом значении сдвигаются на одну позицию вправо. Если
вправо сдвигается целое значение без знака, то старший разряд сбрасывается в нуль.
А если вправо сдвигается целое значение со знаком, то разряд знака сохраняется. Напомним, что для представления отрицательных чисел старший разряд целого числа
устанавливается в 1. Так, если сдвигаемое значение является отрицательным, то при
каждом сдвиге вправо старший разряд числа устанавливается в 1. А если сдвигаемое
значение является положительным, то при каждом сдвиге вправо старший разряд числа сбрасывается в нуль.

При сдвиге влево и вправо крайние двоичные разряды теряются. Восстановить потерянные при сдвиге двоичные разряды нельзя, поскольку сдвиг в данном случае не
является циклическим.

Ниже приведен пример программы, наглядно демонстрирующий действие сдвига
влево и вправо. В данном примере сначала задается первоначальное целое значение,
равное 1. Это означает, что младший разряд этого значения установлен. Затем это целое значение сдвигается восемь раз подряд влево. После каждого сдвига выводятся восемь младших двоичных разрядов данного значения. Далее процесс повторяется, но на
этот раз 1 устанавливается на позиции восьмого разряда, а по существу, задается целое
значение 128, которое затем сдвигается восемь раз подряд вправо.
```
// Продемонстрировать применение операторов сдвига.
using System;

class ShiftDemo {
    static void Main() {
        int val = 1;
        for(int i = 0; i < 8; i++) {
            for(int t=128; t > 0; t = t/2) {
                if((val & t) != 0) Console.Write("1 ");
                if((val & t) == 0) Console.Write("0 ");
            }
            Console.WriteLine();
            val = val << 1; // сдвиг влево
        }
        Console.WriteLine();
        val = 128;
        for(int i = 0; i < 8; i++) {
            for(int t=128; t > 0; t = t/2) {
                if((val & t) != 0) Console.Write("1 ");
                if((val & t) == 0) Console.Write("0 ");
            }
            Console.WriteLine();
            val = val >> 1; // сдвиг вправо
        }
    }
}
```
Результат выполнения этой программы выглядит следующим образом.
```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 1 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0
0 1 0 0 0 0 0 0
1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1
```
Двоичные разряды соответствуют форме представления чисел в степени 2, и поэтому операторы сдвига могут быть использованы для умножения или деления целых
значений на 2. Так, при сдвиге вправо целое значение удваивается, а при сдвиге влево — уменьшается наполовину. Разумеется, все это справедливо лишь в том случае,
если крайние разряды не теряются при сдвиге в ту или иную сторону. Ниже приведен
соответствующий пример.
```
// Применить операторы сдвига для умножения и деления на 2.
using System;

class MultDiv {
    static void Main() {
        int n;
        n = 10;
        Console.WriteLine("Значение переменной n: " + n);
        // Умножить на 2.
        n = n << 1;
        Console.WriteLine("Значение переменной n после " +
                        "операции n = n * 2: " + n);
        // Умножить на 4.
        n = n << 2;
        Console.WriteLine("Значение переменной n после " +
                        "операции n = n * 4: " + n);
        // Разделить на 2.
        n = n >> 1;
        Console.WriteLine("Значение переменной n после " +
                        "операции n = n / 2: " + n);
        // Разделить на 4.
        n = n >> 2;
        Console.WriteLine("Значение переменной n после " +
                        "операции n = n / 4: " + n);
        Console.WriteLine();

        // Установить переменную n в исходное состояние.
        n = 10;
        Console.WriteLine("Значение переменной n: " + n);
        // Умножить на 2 тридцать раз.
        n = n << 30; // данные теряются
        Console.WriteLine("Значение переменной п после " +
                        "сдвига на 30 позиций влево: " + n);
    }
}
```
Ниже приведен результат выполнения этой программы.
```
Значение переменной n: 10
Значение переменной n после операции n = n * 2: 20
Значение переменной n после операции n = n * 4: 80
Значение переменной n после операции n = n / 2: 40
Значение переменной n после операции n = n / 4: 10
Значение переменной n: 10
Значение переменной n после сдвига на 30 позиций влево: -2147483648
```
Обратите внимание на последнюю строку приведенного выше результата. Когда
целое значение 10 сдвигается влево тридцать раз подряд, информация теряется, поскольку двоичные разряды сдвигаются за пределы представления чисел для типа int.
В данном случае получается совершенно "непригодное" значение, которое оказывается
к тому же отрицательным, поскольку в результате сдвига в старшем разряде, используемом в качестве знакового, оказывается 1, а следовательно, данное числовое значение
должно интерпретироваться как отрицательное. Этот пример наглядно показывает,
что применять операторы сдвига для умножения иди деления на 2 следует очень аккуратно. (Подробнее о типах данных со знаком и без знака см. в главе 3.)

### Поразрядные составные операторы присваивания
Все двоичные поразрядные операторы могут быть использованы в составных операциях присваивания. Например, в двух приведенных ниже операторах переменной
х присваивается результат выполнения операции исключающее ИЛИ над первоначальным значением переменной х и числовым значением 127.
```
х = х ^ 127;
х ^= 127;
```

## Оператор ?
Оператор ? относится к числу самых примечательных в С#. Он представляет собой условный оператор и часто используется вместо определенных видов конструкций
if-then-else. Оператор ? иногда еще называют тернарным, поскольку для него требуются три операнда. Ниже приведена общая форма этого оператора.
```
Выражение! ? Выражение2 : Выражение3;
```
Здесь Выражение1 должно относиться к типу bool, а Выражение2 и Выражение3 —
к одному и тому же типу. Обратите внимание на применение двоеточия и его местоположение в операторе ?.

Значение выражения ? определяется следующим образом. Сначала вычисляется
Выражение1. Если оно истинно, то вычисляется Выражение2, а полученный результат
определяет значение всего выражения ? в целом. Если же Выражение1 оказывается
ложным, то вычисляется Выражение3, и его значение становится общим для всего выражения ?. Рассмотрим следующий пример, в котором переменной absval присваивается значение переменной val.
```
absval = val < 0 ? -val : val; // получить абсолютное значение переменной val
```
В данном примере переменной absval присваивается значение переменной val,
если оно больше или равно нулю. Если же значение переменной val отрицательно, то
переменной absval присваивается результат отрицания этого значения, что в итоге
дает положительное значение.

Ниже приведен еще один пример применения оператора ?. В данной программе
одно число делится на другое, но при этом исключается деление на нуль.
```
// Исключить деление на нуль, используя оператор?.
using System;

class NoZeroDiv {
    static void Main() {
        int result;
        for(int i = -5; i < 6; i++) {
            result = i != 0 ? 100 / i : 0;
            if (i ! = 0)
            Console.WriteLine("100 / " + i + " равно " + result);
        }
    }
}
```
Выполнение этой программы дает следующий результат.
```
100 / -5 равно -20
100 / -4 равно -25
100 / -3 равно -33
100 / -2 равно -50
100 / -1 равно -100
100 / 1 равно 100
100 / 2 равно 50
100 / 3 равно 33
100 / 4 равно 25
100 / 5 равно 20
```
Обратите особое внимание на следующую строку из приведенной выше программы.
```
result = i != 0 ? 100 / i : 0;
```
В этой строке переменной result присваивается результат деления числа 100 на
значение переменной i. Но это деление осуществляется лишь в том случае, если значение переменной i не равно нулю. Когда же оно равно нулю, переменной result
присваивается значение, обнуляющее результат.

Присваивать переменной результат выполнения оператора ? совсем не обязательно. Например, значение, которое дает оператор ?, можно использовать в качестве аргумента при вызове метода. А если все выражения в операторе ? относятся к типу bool,
то такой оператор может заменить собой условное выражение в цикле или операторе
if. В приведенном ниже примере программы выводятся результаты деления числа
100 только на четные, ненулевые значения.
```
// Разделить только на четные, ненулевые значения.
using System;

class NoZeroDiv2 {
    static void Main() {
        for(int i = -5; i < 6; i++)
            if(i != 0 ? (i%2 == 0) : false)
                Console.WriteLine("100 / " + i + " равно " + 100 / i);
    }
}
```
Обратите внимание на оператор if в приведенной выше программе. Если значение
переменной i равно нулю, то оператор if дает ложный результат. А если значение
переменной i не равно нулю, то оператор if дает истинный результат, когда значение
переменной i оказывается четным, и ложный результат, если оно нечетное. Благодаря
этому допускается деление только на четные и ненулевые значения. Несмотря на то
что данный пример служит лишь для целей демонстрации, подобные конструкции
иногда оказываются весьма полезными.

## Использование пробелов и круглых скобок
В выражении на C# допускается наличие символов табуляции и пробелов, благодаря которым оно становится более удобным для чтения. Например, оба приведенных
ниже выражения, по существу, одинаковы, но второе читается легче.
```
х=10/у*(127+х);
х = 10 / у * (127 + х);
```
Скобки могут служить для группирования подвыражений, по существу, повышая
порядок предшествования заключенных в них операций, как в алгебре. Применение
лишних или дополнительных скобок не приводит к ошибкам и не замедляет вычисление выражения. Поэтому скобки рекомендуется использовать, чтобы сделать более
ясным и понятным порядок вычисления как для самого автора программы, так и для
тех, кто будет разбираться в ней впоследствии. Например, какое из двух приведенных
ниже выражение легче читается?
```
х = у/3-34*temp+127;
х = (у/3) - (34*temp) + 127;
```

## Предшествование операторов
В табл. 4.2 приведен порядок предшествования всех операторов в С#: от самого высокого до самого низкого. В таблицу включен ряд операторов, рассматриваемых далее
в этой книге.

| Наивысший порядок |     |                    |                  |                  |                 |                 |        |        |           |
|-------------------|-----|--------------------|------------------|------------------|-----------------|-----------------|--------|--------|-----------|
| ()                | []  | .                  | ++ (постфиксный) | -- (постфиксный) | checked         | new             | sizeof | typeof | unchecked |
| !                 | ~   | (приведение типов) | + (унарный)      | - (унарный)      | ++ (префиксный) | -- (префиксный) |        |        |           |
| *                 | /   | %                  |                  |                  |                 |                 |        |        |           |
| <<                | >>  |                    |                  |                  |                 |                 |        |        |           |
| <                 | >   | <=                 | >=               | is               |                 |                 |        |        |           |
| ==                | !=  |                    |                  |                  |                 |                 |        |        |           |
| &                 |     |                    |                  |                  |                 |                 |        |        |           |
| ^                 |     |                    |                  |                  |                 |                 |        |        |           |
| &vert;            |     |                    |                  |                  |                 |                 |        |        |           |
| &&                |     |                    |                  |                  |                 |                 |        |        |           |
| &vert;&vert;      |     |                    |                  |                  |                 |                 |        |        |           |
| ??                |     |                    |                  |                  |                 |                 |        |        |           |
| ?:                |     |                    |                  |                  |                 |                 |        |        |           |
| =                 | op= | =>                 |                  |                  |                 |                 |        |        |           |
| Наинизший порядок |     |                    |                  |                  |                 |                 |        |        |           |
